States
==========

Los estados son creados en el init del modelo.

```js
redity.init = initial => {
  initial.states = {
    name: 'Erick',
    list: []
  }
}
```

## Cambios de Estado.

`init` crea estados con valores iniciales y los convierte en funciones para cambiar su valor en el modelo la cual lo hace mas flexible.
Tomaremos el ejemplo anterior de los estados iniciales.

```js
redity.onListen = (payload, states, header) => {
  const { name, list } = states
  
  name('Juan') // Cambiando su valor de Erick a Juan
  list({ }) // Cambiando su valor de un Array a un Objeto
  
}
```

> Si, así de simple es cambiar su valor.

Los estados al cambiar su valor informan al subcriber, un middleware que verificá a que conexión debe ser el render. Resulta que cada conexión con los componentes que hacemos, no siempre le pasamos todos los estados, tal vez ni requiera nada de dichos estados del modelo, mas que solamente las acciones. Entonces por ello no puede generarle un render y eso lo sabe muy bien el Middleware Subscriber.

Digamos que tenemos dos componentes, `Main` y `Content`, ambos están conectados al mismo modelo y que este modelo tiene 2 estados inicializados , `name` y `email` y acciones. Solo el componente `Content` tiene conectado un estado que es `name` mientras que `Main` solo tiene las acciones. Si el estado `name` cambia su valor, Subscriber solo dirá a la conexión que tiene el Componente `Content` que genere un render para refresque la vista con el nuevo valor del estado `name`. Por el lado de `Main` no pasará nada porque no tiene un conexión con ningún estado. Ahora si hay un cambio de valor en el estado `email`, pasará que, como ambos no tienen conectada ese estado por ello no pasará nada pero en el store del modelo habrá cambiado su valor.

State tambien tiene sus responsabilidades. Cuando un nuevo valor es el mismo que el valor actual pues no lo tomará en cuenta, simplemente lo ignorará hasta que le des un estado nuevo.

## History

Resulta que hay ocasiones donde cambiamos los valores de los estados y luego por alguna lógica de falla queremos retornar su valor anterior, history, crea un historial del estado para así volver a su pasado. Esto por defecto está desactivado, si queremos que registre su historial debemos ir al init del modelo.
El history tiene un limite de almacenamiento que por defecto es de __2__, si deseamos que almacene mas podemos informarle con la propiedad `deep`.

```js
redity.init = (initial, settings) => {
  initial.states = {
    name: 'Erick'
  }
  
  settings.states = {
    name: {
      history: true,
      deep: 10
    }
  }
}
```

El historial solo puede soportar hasta un `deep` de 100.
Con esto podremos volver a su pasado con su metodo `past`

```js
// listen.js
// ...
states.name.past()
```

## Tipos de Valores

Los estados pueden recibir cualquier tipo de valor pero si queremos ser mas estrictos podemos mencionar en el init el tipo de valor debe recibir, por tanto, cuando el estado reciba un valor que no corresponde al tipo mencionado en el init, saltará un error, evitando que el estado se actualice con ese valor dado.

```js
const { Enum } from 'redity'
settings.states = {
  name: {
    typeValue: [String, Boolean]
  },
  email: {
    typeValue: String
  },
  colors: {
    typeValue: Enum('red', 'blue', 'yellow')
  }
}
```

Los tipos reciben un constructor nativo. en caso de querer especificar mas de un tipo, pues los agrupamos en un Array, y si queremos definir unos valores especificos usamos Enum de Redity, la cual debemos importarlo.

> Mas adelante se está pensando aceptar expresiones regulares.


## Obteniendo sus valores.

Para obtener los estados en los componentes lo hacemos con el método `connect` por `mapStateToProps`, pasandole los valor por props.

```js
const mapStateToProps = states => ({
  colors: states.colors
})

export default connect('myModel', mapStateToProps)(MyComponent)
```

Pero hay casos donde vamos a requerir obtener el valor del estado en el modelo por ello podemos usar las mismas funciones que usamos para cambiar sus valores. Si no le otorgamos datos pues `State` solo te retornará el valor, no informará nada para un posible render.

```js
const { name } = states

const value = name()
```
Si le pasamos un valor nos retornará el valor actualizado.

## Unseen

Unseen es una función del estado que nos ayuda a evitar multiples render por causa de muchos seteo en una sola acción.

```js
//listen.js
// Decimos que tenemos inicializado varios estados.

export default async (payload, states, header) => {
  states.name.unseen('Pablo')
  states.lastName.unseen('Navarrete')
  states.age(18)
}
```

Lo que hace unseen es cambiar el valor de manera desapercibida, eso quiere decir que no genera un render a los Componentes que esten mostrado ese valor del estado. Pero vamos a necesitar del alguien que genere ese render porque sino perdemos estos valores seteados, por ello el estado `age` será el encargado, el último. Si se fijan no ejecuta el metodo `unseen`

## Init

Este metodo se encargará de volver a su valor inicial del estado

```js
//listen.js
// Decimos que tenemos inicializado varios estados.

export default async (payload, states, header) => {
  states.name.init()
}
```