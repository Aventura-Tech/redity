States
==========

Los estados son creados en el init del modelo.

```js
redity.init = initial => {
  initial.states = {
    name: 'Erick',
    list: []
  }
}
```

Al momento de crearse el modelo, nos prepara varias herremientas que usaremos.

## Cambios de Estado.

init crea estados con valores iniciales y los convierte en funciones para cambiar su valor en el modelo la cual lo hace mas flexible.
Tomaremos el ejemplo anterior de los estados iniciales.

```js
redity.onListen = (res, states, header) => {
  const { name, list } = states
  
  name('Juan') // Cambiando su valor de Erick a Juan
  list({ }) // Cambiando su valor de un Array a un Objeto
  
}
```

> Si, as칤 de simple es cambiar su valor.

Los estados al cambiar su valor informan al subcriber, un middleware que verific치 a que conexi칩n debe ser el render. Resulta que cada conexi칩n con los componentes que hacemos, no siempre le pasamos todos los estados, tal vez ni requiera nada de dichos estados del modelo, mas que solamente las acciones. Entonces por ello no puede generarle un render y eso lo sabe muy bien el Middleware Subscriber.

Digamos que tenemos dos componentes, `Main` y `Content`, ambos est치n conectados al mismo modelo y que este modelo tiene 2 estados inicializados , `name` y `email` y acciones. Solo el componente `Content` tiene conectado un estado que es `name` mientras que `Main` solo tiene las acciones. Si el estado `name` cambia su valor, Subscriber solo dir치 a la conexi칩n que tiene el Componente `Content` que genere un render para refresque la vista con el nuevo valor del estado `name`. Por el lado de `Main` no pasar치 nada porque no tiene un conexi칩n con ning칰n estado. Ahora si hay un cambio de valor en el estado `email`, pasar치 que, como ambos no tienen conectada ese estado por ello no pasar치 nada pero en el store del modelo habr치 cambiado su valor.

State tambien tiene sus responsabilidades. Cuando un nuevo valor es el mismo que el valor actual pues no lo tomar치 en cuenta, simplemente lo ignorar치 hasta que le des un estado nuevo.

## History

Resulta que hay ocasiones donde cambiamos los valores de los estados y luego por alguna l칩gica de falla queremos retornar su valor anterior, history, crea un historial del estado para as칤 volver a su pasado. Esto por defecto est치 desactivado, si queremos que registre su historial debemos ir al init del modelo.
El history tiene un limite de almacenamiento que por defecto es de __2__, si deseamos que almacene mas podemos informarle con la propiedad `deep`.

```js
redity.init = (initial, settings) => {
  initial.states = {
    name: 'Erick'
  }
  
  settings.states = {
    name: {
      history: true,
      deep: 10
    }
  }
}
```

El historial solo puede soportar hasta un `deep` de 100 por ello no malgastar n칰meros 游때
Con esto podremos volver a su pasado con su metodo `past`

```js
// listen.js
// ...
states.name.past()
```

## Tipos de Valores

Los estados pueden recibir cualquier tipo de valor pero si queremos ser mas estrictos podemos mencionar en el init el tipo de valor debe recibir, por tanto, cuando el estado reciba un valor que no corresponde al tipo mencionado en el init, saltar치 un error, evitando que el estado se actualice con ese valor dado.

```js
settings.states = {
  name: {
    typeValue: [String, Boolean]
  },
  email: {
    typeValue: String
  },
  colors: {
    typeValue: Enum('red', 'blue', 'yellow')
  }
}
```

Los tipos reciben un constructor nativo. en caso de querer especificar mas de un tipo, pues los agrupamos en un Array, y si queremos definir unos valores especificos usamos Enum de Redity, la cual debemos importarlo.

> Mas adelante se est치 pensando aceptar expresiones regulares.


## Obteniendo sus valores.

Para obtener los estados en los componentes lo hacemos con el m칠todo `connect` por `mapStateToProps`, pasandole los valor por props.

```js
const mapStateToProps = states => ({
  colors: states.colors
})

export default connect('myModel', mapStateToProps)(MyComponent)
```

Pero hay casos donde vamos a requerir obtener el valor del estado en el modelo por ello podemos usar las mismas funciones que usamos para cambiar sus valores. Si no le otorgamos datos pues `State` solo te retornar치 el valor, no informar치 nada para un posible render.

```js
const { name } = states

const value = name()
```
Si le pasamos un valor nos retornar치 el valor actualizado.

## Unseen

Unseen es una funci칩n del estado que nos ayuda a evitar multiples render por causa de muchos seteo en una sola acci칩n.

```js
//listen.js
// Decimos que tenemos inicializado varios estados.

export default async (payload, states, header) => {
  states.name.unseen('Pablo')
  states.lastName.unseen('Navarrete')
  states.age(18)
}
```

Lo que hace unseen es cambiar el valor de manera desapercibida, eso quiere decir que no genera un render a los Componentes que esten mostrado ese valor del estado. Pero vamos a necesitar del alguien que genere ese render porque sino perdemos estos valores seteados, por ello el estado `age` ser치 el encargado, el 칰ltimo. Si se fijan no ejecuta el metodo `unseen`