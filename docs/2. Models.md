Models
===========

El sistema de modelo nació con el objetivo de separar la lógica de la interfaz.

Un modelo está conforamados por:

* initial
* listener
* fail

#### Initial

Será el encargado de inicializar los estados, dispatchers y las configuraciones que se le puede dar.

#### Listener

Será el encargado de capturar todos las acciones generado por los dispatcher.

#### Fail

Será el encargado de tomar todos los errores que haya ocurrido en el listener. Ejemplo en una petición con error 400

Los modelos debemos agruparlos en un directorio `/models`

```js
// models/MyModel.js

export default = redity => {
  // initial
  redity.init =  (initial, settings) => {
    // your code...
  }
  
  // listener
  redity.onListen = async (payload, states, header)  => {
    // your code
  }
  
  // fails
  redity.onFail = async (err, states, header) => {
    // your code
  }
  
  // required
  return redity
}
```
> onListen como onFail deben ser async

Algo que se recomienda es separar estos tipos de eventos del modelo en un archivo propio.

```
|-- MyModel
|   |-- initial.js
|   |-- listener.js
|   |-- fail.js
|   |-- index.js
|-- MyOtherModel
|   |-- init.js
|   |-- ...
| ...
```

La cual index será el encargado de agrupar a todos ellos.

```js
import initial from './initial'
import listener from './listener'
import fail from './fail'

export default redity => {
  redity.init = initial
  redity.onListen = listener
  redity.onFail = fail
  return redity
}
```

> onListen como onFail pueden ser opcionales

## Register

El modelo que creemos tenemos que informale a Redity, por ello debemos registrarlo. Cada registro de un modelo requerirá de un identificador para luego identificarlos en las conexiones. Uno de las cosas agradables es que podemos reusar el Modelo.

```js
// src/app.js

import Redity from 'redity'

import MyModel from './models/MyModel'
import MyModel2 from './models/MyModel2'

Redity
  .register('MyModelOfExample', MyModel)
  .register('MyOtherModel', MyModel2)
  .register('ReusingModel', MyModel)
// ...
```


Algo que se recomienda es crear un archivo llamado `register.js` o `redity.js` eh importarlo en la raíz de la App


## Connection

Supongamos que hayamos inicializados dos estados, `name` y `email`; y dos dispatchers, `changeName` y `changeEmail`.

```jsx
import React from 'react'
import { connect } from 'redity'

function MyComponent({ name, changeName }){
  return (<div>
    <p>{ name }</p>
    <button onClick={ () => changeName('Eduardo') } >Change Name</button>
  </div>)
}

const mapStateToProps = states => ({
  name: states.name
})

const mapDispatchToProps = dispatch => ({
  changeName: dispatch.changeName
})

export default connect('MyModel', mapStateToProps, mapDispatchToProps)(MyComponent)
```

Con esto estamos diciendole que se conecte al modelo `MyModel` y que le otorgue a este componente el estado `name` y el dispatch `changeName` que será ejecutado cuando demos click en el botom. Cuando el dispatch sea ejecutada será enviada al modelo, la cual lo captura por el Listener donde podemos crear nuestra lógica y decirle que cambie el valor del estado `name`

```js
//listener.js

export default async (payload, states, header) => {
  states.name(payload)
}
```

__Payload__ sería el dato enviado por el dispatch y __states__ serán los que contienen los estados en metodos. [Lease la sección States]()

Por el lado de __header__, nos otorga un objeto llamada components en donde podremos visualizar todos los componentes conectados y sus props que recibe del __padre__, esto es genial cuando hacemos conexiones con otras librerías que nos otorga estos props y podamos tenerlo en nuestro modelo. Esto ayudará mucho cuando usemos un `router`.

## ¿Como funciona onFail?

Digamos que hacemos una petición Rest Api y este falla, onFail capturará esa falla en la cual ahí tu podrás crear una lógica para manejar ese error. Para que esto resulte tenemos que usar `await`.

Para este caso digamos que la petición falla

```js
// listener.js
export default async (catchErr, states, header) => {
  if(header.action === 'getUsers'){
    await Api.get('https://api.com/users')
  }
}
```

```js
// fail.js
export default async (err, states, header) => {
  if(header.action === 'getUsers'){
    states.message('Error in the API') // Cambiando el estado de message que debe existir en el initial.
    header.dispatchers.getUsers() // renviando hacer la petición.
  }
}
```

Podemos generar un error con `throw` como ejemplo.

```js
// listener.js
// ...
throw new Error('Generate a error')
// ...
```

## Access

Resulta que cada modelo es independiente, no comparten ni interactúan entre ellos. Si queremos compartir sus estados o dispatcher los podemos hacer configurando en el initial.

```js
// initial.js
export default (initial, settings) => {
  initial.states = {
    name: 'Juan'
  }

  initial.dispatchers = {
    changeName: null
  }

  settings.publicStates = true
  settings.publicDispatchers = true
}
```

```js
// ...
const mapStateToProps = (states, globalStates) => ({
  name: states.name,
  nameOfOtherModel: globalStates.OtherModel.name
})

const mapDispatchToProps = (dispatch, globalDispatch) => ({
  changeName: dispatch.changeName,
  changeNameOfOtherModel: globalDispatch.OtherModel.changeName
})

export default connect('MyModel', mapStateToProps, mapDispatchToProps)(MyComponent)
```

Y lo podemos importar tambien en el modelo

```js
// listener.js of MyModel
export default async (payload, states, header) => {
  const { OtherModel } = header.models
  OtherModel.dispatchers.changeName('Arturo')
  OtherModel.states.name() // print...
}

```


